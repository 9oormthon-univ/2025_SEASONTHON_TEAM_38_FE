//
//  CalendarView.swift
//  SimHae
//
//  Created by ÌôçÏ§ÄÎ≤î on 9/4/25.
//

import SwiftUI

struct CalendarTotalView: View {
    @State private var isShowingDateChangeSheet: Bool = false
    @EnvironmentObject var calendarViewModel: CalendarViewModel
    //@ObservedObject var calendarViewModel: CalendarViewModel
    @StateObject private var searchVM: SearchViewModel
    
    @FocusState private var isSearching
//    @State private var searchQuery: String = ""
    @State private var isbackgroundBlur: Bool = false
    
    init(calendarViewModel: CalendarViewModel) {
        //_calendarViewModel = ObservedObject(wrappedValue: calendarViewModel)
        
        let repo = APISearchRepository()
        _searchVM = StateObject(
            wrappedValue: SearchViewModel(repo: repo) { item in
                calendarViewModel.didTap(date: item.date)
            }
        )
    }
    
    private var weekday: [String] = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"]
    
    var body: some View {
        VStack {
            Image(.appLogo)
                .resizable()
                .aspectRatio(contentMode: .fit)
                .frame(height: 18)
                .padding(.top, 24)

            ScrollView(.vertical,
                       showsIndicators: false) {
                VStack {
                    searchBar
                        .padding(.top, 20)
                    YearMonthHeaderView(calendarViewModel: calendarViewModel, isShowingDateChangeSheet: $isShowingDateChangeSheet)
                        .foregroundStyle(.white)
                        .padding(.top, 8)
                        .padding(.leading, 16)
                        .frame(maxWidth: .infinity, alignment: .leading)
                    CalendarView(calendarViewModel: calendarViewModel, weekday: weekday)
                        .padding(.horizontal, 16)
                    
                    if calendarViewModel.dreamsForSelected.isEmpty {
                        Text(calendarViewModel.emptyMessageForSelected)
                            .foregroundStyle(.white.opacity(0.6))
                            .padding(.top, 16)
                    } else {
                        VStack(spacing: 12) {
                            ForEach(calendarViewModel.dreamsForSelected) { item in
                                NavigationLink {
                                    DetailView(vm: DreamDetailViewModel(dreamId: item.id))
                                        .environmentObject(calendarViewModel)
                                } label: {
                                    DreamCard(date: item.dreamDate.formatted(.dateTime.year().month().day().weekday(.wide).locale(Locale(identifier: "ko_KR"))), title: item.title, summary: item.summary, emoji: item.emoji ?? "üåô")
                                        .contentShape(Rectangle())
                                }
                                .buttonStyle(.plain)
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.vertical, 16)
                    }
                }
            }
                       .padding(.bottom, 28)
            .onAppear {
                // CalendarTotalView.onAppear
                print("üü£ CalendarTotalView VM:", ObjectIdentifier(calendarViewModel),
                      "selected:", calendarViewModel.selectDate)
                print("üìÖ CalendarTotalView appeared")
                // ‚úÖ Ï¥àÍ∏∞ Î°úÎî©: ÏõîÎ≥Ñ + ÏÑ†ÌÉùÎêú ÎÇ†Ïßú Îç∞Ïù¥ÌÑ∞
                calendarViewModel.fetchMonthEmojisForVisibleMonth()
                calendarViewModel.fetchIfNeeded(for: calendarViewModel.selectDate, force: calendarViewModel.isToday(calendarViewModel.selectDate))
            }
            .onChange(of: calendarViewModel.selectDate) { newDate in
                calendarViewModel.fetchIfNeeded(for: newDate, force: calendarViewModel.isToday(newDate))
            }
            //.padding(.horizontal, 16) ÏñòÍ∞Ä Î∑∞Î•º ÏûêÍæ∏ ÎäòÏóàÎã§ Ï§ÑÏòÄÎã§Ìï®.
        }
        .background{
            Image("CalendarBackgroundVer2")
                .resizable()
                .scaledToFill()
                .ignoresSafeArea(edges: .top)
        }
        .blur(radius: isbackgroundBlur ? 20 : 0)
//        .onChange(of: isSearching) {
//            withAnimation {
//                DispatchQueue.main.async {
//                    isbackgroundBlur.toggle()
//                }
//            }
//        }
        .onChange(of: isSearching) { newValue in
            withAnimation {
                isbackgroundBlur = newValue        // ‚Üê toggle() ÎßêÍ≥† Í∞í Í∑∏ÎåÄÎ°ú Î∞òÏòÅ
            }
            if !newValue {
                calendarViewModel.resetSearch()    // ‚Üê ÌÇ§Î≥¥Îìú ÎÇ¥Î†§Í∞ÄÎ©¥ Í≤ÄÏÉâÏñ¥/Í≤∞Í≥º Ï¥àÍ∏∞Ìôî
            }
        }
        .overlay {
            if isSearching {
                Color.black.opacity(0.25)
                               .ignoresSafeArea()
                               .onTapGesture { withAnimation { isSearching = false } }
                               .transition(.opacity)
                               .zIndex(0)

                
                VStack(spacing: 0) {
                    // Ìó§Îçî
                    Image(.appLogo)
                        .resizable()
                        .aspectRatio(contentMode: .fit)
                        .frame(height: 18)
                        .padding(.top, 24)

                    searchBar
                        .padding(.top, 20)

                    // üîé Í≤ÄÏÉâ Í≤∞Í≥ºÎßå Î†åÎçî
                    ScrollView(showsIndicators: false) {
                        VStack(spacing: 12) {
                            if calendarViewModel.isLoading {
                                ProgressView()
                                    .tint(.white)
                                    .padding(.top, 24)

                            } else {
                                let q = calendarViewModel.searchQuery.trimmingCharacters(in: .whitespacesAndNewlines)

                                if q.isEmpty {
                                    Text("Í≤ÄÏÉâÏñ¥Î•º ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî")
                                        .foregroundStyle(.white.opacity(0.6))
                                        .padding(.top, 24)

                                } else if calendarViewModel.isSearchQueryTooShort {
                                    Text("ÏµúÏÜå 2Ïûê Ïù¥ÏÉÅ ÏûÖÎ†•Ìï¥ Ï£ºÏÑ∏Ïöî")
                                        .foregroundStyle(.white.opacity(0.6))
                                        .padding(.top, 24)

                                } else {
                                    let results = calendarViewModel.searchResultsSorted
                                    if results.isEmpty {
                                        Text("Í≤ÄÏÉâ Í≤∞Í≥ºÍ∞Ä ÏóÜÏñ¥Ïöî")
                                            .foregroundStyle(.white.opacity(0.6))
                                            .padding(.top, 24)
                                    } else {
                                        ForEach(results) { item in
                                            NavigationLink {
                                                DetailView(vm: DreamDetailViewModel(dreamId: item.id))
                                            } label: {
                                                DreamCard(
                                                    date: item.dreamDate.formatted(
                                                        .dateTime.year().month().day().weekday(.wide)
                                                            .locale(Locale(identifier: "ko_KR"))
                                                    ),
                                                    title: item.title,
                                                    summary: item.summary,
                                                    emoji: item.emoji ?? "üåô"
                                                )
                                                .contentShape(Rectangle())
                                            }
                                            .buttonStyle(.plain)
                                        }
                                    }
                                }
                            }
                        }
                        .padding(.horizontal, 16)
                        .padding(.top, 12)
                        .padding(.bottom, 24)
                    }

                    Spacer(minLength: 0)
                }
//                .frame(maxWidth: .infinity, maxHeight: .infinity, alignment: .top)
                .padding(.top, 8)
                .transition(.opacity)
                // ÏïÑÎûò Ïª®ÌÖêÏ∏† ÌÑ∞Ïπò/Ïä§ÌÅ¨Î°§ ÎßâÍ∏∞ (Ïò§Î≤ÑÎ†àÏù¥ ÏßÑÏßúÎ°ú ÎçÆÏñ¥Ïì∞Í∏∞)
//                .background(Color.black.opacity(0.001).ignoresSafeArea().onTapGesture {
//                    isSearching = false
//                })
                .zIndex(10)
            }
        }
        //.animation(.easeInOut(duration: 0.28), value: isSearching)
        .toolbar {
            ToolbarItemGroup(placement: .keyboard) {
                Spacer()
                Button("ÏôÑÎ£å") {
                    isSearching = false   // onChangeÏóêÏÑú resetSearch Ìò∏Ï∂úÎê®
                }
            }
        }
//        .overlay {
//            if isSearching {
//                VStack {
//                    Image(.appLogo)
//                        .resizable()
//                        .aspectRatio(contentMode: .fit)
//                        .frame(height: 18)
//                        .padding(.top, 24)
//                    searchBar
//                        .padding(.top, 20)
//                    
//                    
//                    Spacer()
//                }
//            }
//        }

    }
    
    private var searchBar: some View {
        VStack {
            HStack(spacing: 10) {
                Image(systemName: "magnifyingglass")
                    .foregroundStyle(Color(hex: "#FFFFFF"))
                TextField("Íøà ÎÇ¥Ïö©ÏúºÎ°ú Í≤ÄÏÉâÌïòÍ∏∞", text: $calendarViewModel.searchQuery)
                    .focused($isSearching)
                    .foregroundStyle(Color(hex: "#FFFFFF").opacity(0.7))
                    .textInputAutocapitalization(.never)
            }
            .padding(.vertical, 8)
            .padding(.horizontal, 12)
            .background(RoundedRectangle(cornerRadius: 30, style: .circular).fill(Color(hex: "#843CFF").opacity(0.1)))
            .overlay(RoundedRectangle(cornerRadius: 30, style: .circular)
                .stroke(LinearGradient(
                    gradient: Gradient(colors:[
                        Color(hex: "#E8D9FF"),
                        Color(hex: "#7534E4"),
                        Color(hex: "#E8D9FF")
                    ]),
                    startPoint: .topLeading,
                    endPoint: .bottomTrailing
                ),
                        lineWidth: 1)
            )
            .frame(width: 360)
            .padding(.top)
        }
    }
}

struct DreamCard: View {
    let date: String
    let title: String
    let summary: String
    let emoji: String
    
    var body: some View {
        HStack(spacing: 24) {
            //Ïù¥Î™®ÏßÄ + Í∏ÄÎ°úÏö∞
            Text(emoji)
                .font(.system(size: 28))
                .shadow(color: .purple.opacity(0.8), radius: 12, x: 0, y: 0)
            // Ï∂îÍ∞ÄÎ°ú Î∞îÍπ•Ï™Ω Î∂ÄÎìúÎüΩÍ≤å ÌçºÏßê
                .shadow(color: .purple.opacity(0.4), radius: 24, x: 0, y: 0)
                .padding(.leading, 12)
            //ÌÖçÏä§Ìä∏ ÏòÅÏó≠
            VStack(alignment: .leading, spacing: 6) {
                Text(date)
                    .font(.caption)
                    .foregroundStyle(.gray)
                Text(title)
                    .font(.headline)
                    .bold()
                    .foregroundStyle(.white)
                    .lineLimit(1)
                    .truncationMode(.tail)
                    
                Text(summary)
                    .font(.subheadline)
                    .foregroundStyle(.white.opacity(0.7))
                    .lineLimit(1)
                    .truncationMode(.tail)
            }
            
            Image(systemName: "chevron.right")
                .foregroundStyle(.white.opacity(0.6))
        }
        .padding()
        .background(
            RoundedRectangle(cornerRadius: 20, style: .continuous)
            // 1) Ïñ¥ÎëêÏö¥ Î∞∞Í≤Ω Í∑∏ÎùºÎç∞Ïù¥ÏÖò
                .fill(
                    LinearGradient(
                        gradient: Gradient(colors: [Color(hex: "#1A1A1A"), Color(hex: "#0E0E0E")]),
                        startPoint: .topLeading,
                        endPoint: .bottomTrailing
                    )
                )
            // 2) ÌÖåÎëêÎ¶¨ Í∑∏ÎùºÎç∞Ïù¥ÏÖò
                .overlay(
                    RoundedRectangle(cornerRadius: 20, style: .continuous)
                        .stroke(
                            LinearGradient(
                                gradient: Gradient(stops: [
                                    .init(color: Color(hex: "#E8D9FF"), location: 0.0),
                                    .init(color: Color(hex: "#5F21CC"), location: 0.5),
                                    .init(color: Color(hex: "#E8D9FF"), location: 1.0),
                                ]),
                                startPoint: .topLeading,
                                endPoint: .bottomTrailing
                            ),
                            lineWidth: 0.8
                        )
                )
            // 3) ÏñáÏùÄ ÏïàÏ™Ω ÌïòÏù¥ÎùºÏù¥Ìä∏
                .overlay(
                    RoundedRectangle(cornerRadius: 20, style: .continuous)
                        .inset(by: 1)
                        .stroke(Color.white.opacity(0.08), lineWidth: 0.8)
                        .blendMode(.overlay)
                )
        )
        .frame(width: UIScreen.main.bounds.width - 32)
    }
}

struct YearMonthHeaderView: View {
    @ObservedObject var calendarViewModel: CalendarViewModel
    @Binding var isShowingDateChangeSheet: Bool
    
    var body: some View {
        HStack {
            
            Button(action: {
                let cal = Calendar.current
                let lowerBound = cal.date(from: DateComponents(year: 2024, month: 1, day: 1))!
                let prevMonth = cal.date(byAdding: .month, value: -1, to: calendarViewModel.currentDate)!
                
                // 2024-01 Ïù¥Ï†ÑÏúºÎ°úÎäî Î™ª Í∞ÄÍ≤å
                let isPrevBeforeLower = cal.compare(
                    cal.date(from: cal.dateComponents([.year, .month], from: prevMonth))!,
                    to: lowerBound,
                    toGranularity: .month
                ) == .orderedAscending
                
                guard !isPrevBeforeLower else { return }
                
                withAnimation(.easeInOut) {
                    calendarViewModel.currentMonth -= 1
                    calendarViewModel.selectedMonth -= 1
                }
            }) {
                Image(systemName: "chevron.left")
                    .font(.title3.weight(.semibold))
                    .foregroundStyle(.white)
            }
            
            Text("\(calendarViewModel.getYearAndMonthString(currentDate: calendarViewModel.currentDate)[0])ÎÖÑ \(calendarViewModel.getYearAndMonthString(currentDate: calendarViewModel.currentDate)[1])")
                .font(.title3.bold())
            
            // ‚û°Ô∏è Îã§Ïùå Îã¨ Î≤ÑÌäº
            Button(action: {
                let cal = Calendar.current
                let now = Date()
                let nextMonth = cal.date(byAdding: .month, value: 1, to: calendarViewModel.currentDate)!
                
                // ÎØ∏Îûò Îã¨Î°ú ÎÑòÏñ¥Í∞ÄÏßÄ ÏïäÎèÑÎ°ù(Îã§ÏùåÎã¨Ïù¥ Ïò§ÎäòÎ≥¥Îã§ Ïù¥ÌõÑÎ©¥ ÎßâÍ∏∞)
                let isNextBeyondNow = cal.compare(
                    cal.date(from: cal.dateComponents([.year, .month], from: nextMonth))!,
                    to: cal.date(from: cal.dateComponents([.year, .month], from: now))!,
                    toGranularity: .month
                ) == .orderedDescending
                
                guard !isNextBeyondNow else { return }
                
                withAnimation(.easeInOut) {
                    calendarViewModel.currentMonth += 1
                    calendarViewModel.selectedMonth += 1
                }
            }) {
                Image(systemName: "chevron.right")
                    .font(.title3.weight(.semibold))
                    .foregroundStyle(.white)
            }
        }
    }
}

struct CalendarView: View {
    
    @State private var offset: CGSize = CGSize()
    @ObservedObject var calendarViewModel: CalendarViewModel
    
    let weekday: [String]
    
    var body: some View {
        VStack {
            WeekdayHeaderView(weekday: weekday)
            DatesGridView(calendarViewModel: calendarViewModel)
        }
        .padding(.top, 20)
        .onChange(of: calendarViewModel.currentMonth) { newOffset in
            calendarViewModel.didChangeMonth(to: newOffset)
        }
        .gesture(
            DragGesture(minimumDistance: 10, coordinateSpace: .local)
                .onChanged { value in
                    self.offset = value.translation
                }
                .onEnded { value in
                    let cal = Calendar.current
                    
                    // ÌòÑÏû¨ ÎìúÎûòÍ∑∏ vs ÏòàÏ∏° Ï¢ÖÎ£å ÏßÄÏ†ê(=ÏÜçÎèÑ Î∞òÏòÅ)
                    let dx  = value.translation.width
                    let pdx = value.predictedEndTranslation.width
                    // Îçî ÌÅ∞ Ï™ΩÏùÑ ÏµúÏ¢Ö Ï†úÏä§Ï≤òÎ°ú Ï±ÑÌÉù (ÏÜçÎèÑ Í∞ïÌï†ÏàòÎ°ù pdxÍ∞Ä ÌÅº)
                    let finalDx = abs(pdx) > abs(dx) ? pdx : dx
                    
                    // ÏÑ∏Î°ú Ï†úÏä§Ï≤ò Î¨¥Ïãú (Í∞ÄÎ°ú Ïö∞ÏÑ∏Îßå ÌóàÏö©)
                    let dy = value.translation.height
                    guard abs(finalDx) > abs(dy) else { return }
                    
                    // Ïä§ÏôÄÏù¥ÌîÑ Ïù∏Ïãù ÏûÑÍ≥ÑÍ∞í
                    let threshold: CGFloat = 40
                    guard abs(finalDx) > threshold else { return }
                    
                    // ÎÇ†Ïßú Í≤ΩÍ≥Ñ Í≥ÑÏÇ∞
                    let current = calendarViewModel.currentDate
                    let now = Date() // Ïò§Îäò
                    let nextMonth = cal.date(byAdding: .month, value: 1, to: current)!
                    let prevMonth = cal.date(byAdding: .month, value: -1, to: current)!
                    let lowerBound = cal.date(from: DateComponents(year: 2024, month: 1, day: 1))!
                    
                    withAnimation(.easeInOut) {
                        // finalDx < 0  == ÏôºÏ™ΩÏúºÎ°ú ÎØº Ï†úÏä§Ï≤ò(‚Üí Îã§Ïùå Îã¨)
                        if finalDx < 0 {
                            // ÎØ∏Îûò Îã¨Î°ú ÎÑòÏñ¥Í∞ÄÏßÄ ÏïäÎèÑÎ°ù(Îã§ÏùåÎã¨Ïù¥ Ïò§ÎäòÎ≥¥Îã§ Ïù¥ÌõÑÎ©¥ ÎßâÍ∏∞)
                            let isNextBeyondNow = cal.compare(
                                cal.date(from: cal.dateComponents([.year, .month], from: nextMonth))!,
                                to: cal.date(from: cal.dateComponents([.year, .month], from: now))!,
                                toGranularity: .month
                            ) == .orderedDescending
                            guard !isNextBeyondNow else { return }
                            
                            calendarViewModel.currentMonth += 1
                            calendarViewModel.selectedMonth += 1
                            
                        } else { // finalDx > 0  == Ïò§Î•∏Ï™ΩÏúºÎ°ú ÎØº Ï†úÏä§Ï≤ò(‚Üí Ïù¥Ï†Ñ Îã¨)
                            // ÏµúÏÜå 2024-01 Ïù¥Ï†ÑÏúºÎ°úÎäî Î™ª Í∞ÄÍ≤å
                            let isPrevBeforeLower = cal.compare(
                                cal.date(from: cal.dateComponents([.year, .month], from: prevMonth))!,
                                to: lowerBound,
                                toGranularity: .month
                            ) == .orderedAscending
                            guard !isPrevBeforeLower else { return }
                            
                            calendarViewModel.currentMonth -= 1
                            calendarViewModel.selectedMonth -= 1
                        }
                    }
                    
                    self.offset = .zero
                }
        )
        //        .gesture(
        //            DragGesture()
        //                .onChanged { gesture in
        //                    self.offset = gesture.translation
        //                }
        //                .onEnded { gesture in
        //                    let calender = Calendar.current
        //                    let selectYear = calender.component(.year, from: calendarViewModel.currentDate)
        //                    let selectMonth = calender.component(.month, from: calendarViewModel.currentDate)
        //                    let presentMonth = calender.component(.month, from: Date())
        //
        //                    if gesture.translation.width < -20 {
        //                        if selectMonth == presentMonth {
        //
        //                        } else {
        //                            calendarViewModel.currentMonth += 1
        //                            calendarViewModel.selectedMonth += 1
        //                        }
        //                    } else if gesture.translation.width > 20 {
        //                        if selectYear == 2024 && selectMonth == 1 {
        //                        } else {
        //                            calendarViewModel.currentMonth -= 1
        //                            calendarViewModel.selectedMonth -= 1
        //                        }
        //                    }
        //                    self.offset = CGSize()
        //                }
        //        )
    }
}

struct DatesGridView: View {
    @ObservedObject var calendarViewModel: CalendarViewModel
    
    // 7Ïó¥ Í≥†Ï†ï
    private let columns = Array(repeating: GridItem(.flexible(), spacing: 0), count: 7)
    
    // Ï§Ñ Î†àÏù¥ÏïÑÏõÉ(ÎßàÏùåÏóê ÎßûÍ≤å Ïà´ÏûêÎßå Ï°∞Ï†à)
    private let rowHeight: CGFloat = 66   // Ìïú Ï§Ñ(Ïà´Ïûê+Ïù¥Î™®ÏßÄ)Ïùò Í≥†Ï†ï ÎÜíÏù¥
    private let rowSpacing: CGFloat = 2  // Ï§Ñ ÏÇ¨Ïù¥ Í∞ÑÍ≤©
    
    var body: some View {
        // daysÎ•º Ìïú Î≤àÎßå Í≥ÑÏÇ∞Ìï¥ Ïì∞Ïûê
        let days = calendarViewModel.extractDate(currentMonth: calendarViewModel.currentMonth)
        let rows = Int(ceil(Double(days.count) / 7.0))
        
        ZStack(alignment: .topLeading) {
            
            // ÎÇ†Ïßú Í∑∏Î¶¨Îìú
            LazyVGrid(columns: columns, spacing: rowSpacing) {
                ForEach(days) { value in
                    if value.day != -1 {
                        DateButton(value: value,
                                   calendarViewModel: calendarViewModel,
                                   selectDate: $calendarViewModel.selectDate)
                        .frame(height: rowHeight)                 // ‚Üê Ï§Ñ ÎÜíÏù¥ Í≥†Ï†ï
                    } else {
                        // Îπà Ïπ∏ÎèÑ Í∞ôÏùÄ ÎÜíÏù¥Î°ú Ï±ÑÏõå Î†àÏù¥ÏïÑÏõÉ Ïú†ÏßÄ
                        Color.clear
                            .frame(height: rowHeight)
                    }
                }
            }
            
            // Ï£º Íµ¨Î∂ÑÏÑ† Ïò§Î≤ÑÎ†àÏù¥
            GeometryReader { geo in
                ForEach(1..<rows, id: \.self) { i in
                    // iÎ≤àÏß∏ Ï§Ñ ÏïÑÎûòÏóê ÏÑ†ÏùÑ ÍπîÏûê
                    let y = CGFloat(i) * (rowHeight + rowSpacing) - (rowSpacing / 2)
                    
                    Rectangle()
                        .fill(Color(hex: "#FFFFFF").opacity(0.2))            // ÏÑ† ÏÉâ/Ìà¨Î™ÖÎèÑ
                        .frame(height: 0.5)
                        .offset(x: 0, y: y)
                }
            }
            .allowsHitTesting(false) // ÏÑ†Ïù¥ ÌÑ∞Ïπò Î∞©Ìï¥ÌïòÏßÄ ÏïäÎèÑÎ°ù
        }
    }
}

struct DateButton: View {
    var value: DateValue
    @ObservedObject var calendarViewModel: CalendarViewModel
    @Binding var selectDate: Date
    
    private var isSelected: Bool {
        calendarViewModel.isSameDay(date1: value.date, date2: selectDate)
    }
    
    var body: some View {
        VStack(spacing: 6) {
            Button {
                withAnimation(.easeInOut(duration: 0.15)) {
                    calendarViewModel.didTap(date: value.date)
                }
            } label: {
                VStack(spacing: 6) {
                    Text("\(value.day)")
                        .font(.system(size: 17, weight: .semibold))
                        .foregroundStyle(.white)
                        .padding(.horizontal, 10)   // Ï¢åÏö∞ Ïó¨Î∞±
                        .padding(.vertical, 2)                // ÎèôÍ∑∏ÎùºÎØ∏ ÌÅ¨Í∏∞
                        .background(
                            RoundedRectangle(cornerRadius: 100, style: .circular)
                                .fill(Color(hex: "#843CFF")
                                    .opacity(calendarViewModel.highlightOpacity(for: value.date)))
                        )
                    
                    // ÍøàÏù¥ ÏûàÏúºÎ©¥ Ïù¥Î™®ÏßÄ, ÏóÜÏúºÎ©¥ Îπà Í≥µÍ∞Ñ Ïú†ÏßÄ
                    Text(calendarViewModel.emojiForDate(value.date) ?? " ")
                        .font(.system(size: 14))
                        .frame(height: 16)
                }
                .frame(maxWidth: .infinity)
            }
            .disabled(value.date > Date())
        }
    }
}

//#Preview {
//    CalendarView()
//}
struct KeyboardObserver: ViewModifier {
    @State private var isKeyboardVisible = false
    
    func body(content: Content) -> some View {
        content
            .scrollDisabled(isKeyboardVisible) // ÌÇ§Î≥¥Îìú Î≥¥Ïù¥Î©¥ Ïä§ÌÅ¨Î°§ Í∫ºÎ≤ÑÎ¶º
            .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillShowNotification)) { _ in
                isKeyboardVisible = true
            }
            .onReceive(NotificationCenter.default.publisher(for: UIResponder.keyboardWillHideNotification)) { _ in
                isKeyboardVisible = false
            }
    }
}

extension View {
    func disableScrollWhenKeyboardVisible() -> some View {
        self.modifier(KeyboardObserver())
    }
}
